This is the UNIX-98 tty related code change on Aug 04, 2004,
just in case somebody needs to undo it or understand
any breakage.

Hin-Tak Leung <htl10@users.sourceforge.net>
............................................................



Index: cxterm/Tekproc.c
===================================================================
RCS file: /cvsroot/cxterm/cxterm/cxterm/Tekproc.c,v
retrieving revision 1.2
retrieving revision 1.2.2.1
diff -u -b -B -r1.2 -r1.2.2.1
--- cxterm/Tekproc.c	6 May 2003 07:40:19 -0000	1.2
+++ cxterm/Tekproc.c	3 Aug 2004 00:33:42 -0000	1.2.2.1
@@ -1133,9 +1133,9 @@
 static void TekEnq (int status, register int x, register int y)
 {
     register TScreen *screen = &term->screen;
-    int pty = screen->respond;
-    char cplot [7];
+    Char cplot [7];
     int len = 5;
+    int adj = (status != 0) ? 0 : 1;
 
     cplot[0] = status;
     /* Translate x and y to Tektronix code */
@@ -1149,10 +1149,7 @@
     if (screen->gin_terminator == GIN_TERM_EOT)
 	cplot[len++] = '\004';
 
-    if(cplot[0])
-	v_write(pty, cplot, len);
-    else
-	v_write(pty, cplot+1, len-1);
+    v_write(screen->respond, cplot+adj, len-adj);
 }
 
 void TekRun(void)
Index: cxterm/button.c
===================================================================
RCS file: /cvsroot/cxterm/cxterm/cxterm/button.c,v
retrieving revision 1.2
retrieving revision 1.2.2.2
diff -u -b -B -r1.2 -r1.2.2.2
--- cxterm/button.c	6 May 2003 07:40:19 -0000	1.2
+++ cxterm/button.c	4 Aug 2004 18:48:09 -0000	1.2.2.2
@@ -1,4 +1,4 @@
-/* $Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $ */
+/* $Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $ */
 /***********************************************************************
 * Copyright 1994 by Yongguang Zhang.
 * Copyright 1990, 1991 by Yongguang Zhang and Pong Man-Chi.
@@ -308,8 +308,8 @@
 static void SelectionReceived(Widget w, XtPointer client_data, Atom *selection, Atom *type, XtPointer value, long unsigned int *length, int *format)
 {
     int pty = ((XtermWidget)w)->screen.respond;	/* file descriptor of pty */
-    register char *lag, *cp, *end;
-    char *line = (char*)value;
+    register Char *lag, *cp, *end;
+    Char *line = (char*)value;
 				  
     if (*type == 0 /*XT_CONVERT_FAIL*/ || *length == 0 || value == NULL) {
 	/* could not get this selection, so see if there are more to try */
@@ -329,11 +329,12 @@
     lag = line;
     for (cp = line; cp != end; cp++)
 	{
-	    if (*cp != '\n') continue;
+	if (*cp == '\n') {
 	    *cp = '\r';
 	    v_write(pty, lag, cp - lag + 1);
 	    lag = cp + 1;
 	}
+      }
     if (lag != end)
 	v_write(pty, lag, end - lag);
 
@@ -757,7 +758,7 @@
 **	- control characters	[0,0x1f] U [0x80,0x9f]
 **	- separators		[0x20,0x3f] U [0xa0,0xb9]
 **	- binding characters	[0x40,0x7f] U [0xc0,0xff]
-**  	- execeptions
+**  	- exceptions
 */
 static int charClass[256] = {
 /* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */
@@ -1390,8 +1391,7 @@
 EditorButton(register XButtonEvent *event)
 {
 	register TScreen *screen = &term->screen;
-	int pty = screen->respond;
-	char line[6];
+	Char line[6];
 	register unsigned row, col;
 	int button; 
 
@@ -1410,7 +1410,7 @@
 	}
 	line[4] = ' ' + col + 1;
 	line[5] = ' ' + row + 1;
-	v_write(pty, line, 6);
+	v_write(screen->respond, line, 6);
 }
 
 
Index: cxterm/charproc.c
===================================================================
RCS file: /cvsroot/cxterm/cxterm/cxterm/charproc.c,v
retrieving revision 1.2
retrieving revision 1.2.2.1
diff -u -b -B -r1.2 -r1.2.2.1
--- cxterm/charproc.c	6 May 2003 07:40:19 -0000	1.2
+++ cxterm/charproc.c	3 Aug 2004 00:33:42 -0000	1.2.2.1
@@ -1,4 +1,4 @@
-/* $Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $ */
+/* $Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $ */
 /***********************************************************************
 * Copyright 1994 by Yongguang Zhang.
 * Copyright 1990, 1991, 1992 by Yongguang Zhang and Pong Man-Chi.
@@ -1572,10 +1572,10 @@
 }
 
 
-static char *v_buffer;		/* pointer to physical buffer */
-static char *v_bufstr = NULL;	/* beginning of area to write */
-static char *v_bufptr;		/* end of area to write */
-static char *v_bufend;		/* end of physical buffer */
+static Char *v_buffer;		/* pointer to physical buffer */
+static Char *v_bufstr = NULL;	/* beginning of area to write */
+static Char *v_bufptr;		/* end of area to write */
+static Char *v_bufend;		/* end of physical buffer */
 
 /* These lines are modified by Zhuang Hao S.S.* */
 /* #define	ptymask()	(v_bufptr > v_bufstr ? pty_mask : 0) */
@@ -1584,7 +1584,7 @@
 /* Write data to the pty as typed by the user, pasted with the mouse,
    or generated by us in response to a query ESC sequence. */
 
-int v_write(int f, char *d, int len)
+int v_write(int f, Char *data, int len)
 {
 	int riten;
 	int c = len;
@@ -1599,14 +1599,15 @@
 	if (debug) {
 	    fprintf(stderr, "v_write called with %d bytes (%d left over)",
 		    len, v_bufptr - v_bufstr);
-	    if (len > 1  &&  len < 10) fprintf(stderr, " \"%.*s\"", len, d);
+	    if (len > 1  &&  len < 10) 
+	      fprintf(stderr, " \"%.*s\"", len, (char *)data);
 	    fprintf(stderr, "\n");
 	}
 #endif
 
     /* This line is modified by Zhuang Hao S.S.* */
 	if (f != g__pty_fd)
-		return(write(f, d, len));
+		return(write(f, (char *)data, len));
 
 	/*
 	 * Append to the block we already have.
@@ -1635,7 +1636,7 @@
 		    /* still won't fit: get more space */
 		    /* Don't use XtRealloc because an error is not fatal. */
 		    int size = v_bufptr - v_buffer; /* save across realloc */
-		    v_buffer = (char *)realloc(v_buffer, size + len);
+		    v_buffer = (Char *)realloc(v_buffer, size + len);
 		    if (v_buffer) {
 #ifdef DEBUG
 			if (debug)
@@ -1656,7 +1657,7 @@
 	    }
 	    if (v_bufend >= v_bufptr + len) {
 		/* new stuff will fit */
-		memmove( v_bufptr, d, len);
+		memmove( v_bufptr, data, len);
 		v_bufptr += len;
 	    }
 	}
@@ -1708,7 +1709,7 @@
 	    int size = v_bufptr - v_buffer;
 	    int allocsize = size ? size : 1;
 	    
-	    v_buffer = (char *)realloc(v_buffer, allocsize);
+	    v_buffer = (Char *)realloc(v_buffer, allocsize);
 	    if (v_buffer) {
 		v_bufstr = v_buffer + start;
 		v_bufptr = v_buffer + size;
@@ -1823,7 +1824,7 @@
 	/* if there is room to write more data to the pty, go write more */
     /* These lines are modified by Zhuang Hao S.S.* */
     if (v_bufptr > v_bufstr && FD_ISSET (g__pty_fd, &write_mask)) {
-	    v_write(screen->respond, 0, 0); /* flush buffer */
+	    v_write(screen->respond, (Char *)0, 0); /* flush buffer */
 	}
 
 	/* if there are X events already in our queue, it
@@ -2466,7 +2467,7 @@
 		buf[1] = '\n';
 		i++;
 	}
-	v_write(fd, buf, i);
+	v_write(fd, (char *)buf, i);
 }
 
 void unparsefputs (register char *s, int fd)
Index: cxterm/main.c
===================================================================
RCS file: /cvsroot/cxterm/cxterm/cxterm/main.c,v
retrieving revision 1.2
retrieving revision 1.2.2.2
diff -u -b -B -r1.2 -r1.2.2.2
--- cxterm/main.c	6 May 2003 07:40:19 -0000	1.2
+++ cxterm/main.c	3 Aug 2004 17:33:15 -0000	1.2.2.2
@@ -1,5 +1,5 @@
 #ifndef lint
-static char *cxterm_rid="$Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $";
+static char *cxterm_rid="$Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $";
 static char *rid="$XConsortium: main.c,v 1.227.1.2 95/06/29 18:13:15 kaleb Exp $";
 #endif /* lint */
 
@@ -96,27 +96,15 @@
 
 #define ARGUMENT_MAX_LENGTH 255
 
-#ifdef att
-#define ATT
-#endif
-
-#if defined(sgi) && (OSMAJORVERSION >= 5)
+#if defined(__sgi) && (OSMAJORVERSION >= 5)
 #undef SYSV
 #ifndef SVR4
 #define SVR4
 #endif
 #endif
 
-#ifdef SVR4
-#ifndef SYSV
-#define SYSV			/* SVR4 is (approx) superset of SVR3 */
-#endif
-#define ATT
-#define USE_SYSV_UTMP
-/*#ifndef sgi*/			/* this doesn't really work, -ygz */ 
+#if defined(SVR4) && !defined(__sgi)
 #define USE_TERMIOS
-/*#endif*/
-#define HAS_UTMP_UT_HOST
 #endif
 
 #if defined(SYSV) && defined(i386) && !defined(SVR4)
@@ -126,7 +114,7 @@
 static Bool IsPts = False;
 #endif
 
-#if defined(ATT) && !defined(sgi)
+#if (defined(ATT) && !defined(__sgi))  || (defined(SYSV) && defined(i386)) || (defined (__GLIBC__) && ((__GLIBC__ > 2) || (__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
 #define USE_USG_PTYS
 #else
 #define USE_HANDSHAKE
@@ -153,6 +141,9 @@
 #define LASTLOG
 #define WTMP
 #include <sys/termios.h>
+#if (__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1))
+#include <pty.h>
+#endif
 #endif
 
 #include <sys/ioctl.h>
@@ -178,7 +169,7 @@
 #undef TIOCSLTC				/* defined, but not useable */
 #endif
 
-#if defined(sgi) && OSMAJORVERSION >= 5
+#if defined(__sgi) && (OSMAJORVERSION >= 5)
 #undef TIOCLSET				/* defined, but not useable */
 #endif
 
@@ -236,8 +227,12 @@
 #endif
 #else /* } !SYSV { */			/* BSD systems */
 #ifndef linux
+#ifndef USE_POSIX_TERMIOS
+#ifndef USE_SYSV_TERMIO
 #include <sgtty.h>
 #endif
+#endif /* USE_POSIX_TERMIOS */
+#endif
 #include <sys/resource.h>
 #define HAS_UTMP_UT_HOST
 #define HAS_BSD_GROUPS
@@ -255,8 +250,8 @@
 #endif
 
 #include <stdio.h>
-#include <errno.h>
 #include <setjmp.h>
+#include <errno.h>
 
 #ifdef X_NOT_STDC_ENV
 extern int errno;
@@ -271,7 +266,7 @@
 #include <sys/utsname.h>
 #endif /* hpux */
 
-#if defined(apollo) && OSMAJORVERSION == 10 && OSMINORVERSION < 4
+#if defined(apollo) && (OSMAJORVERSION == 10) && (OSMINORVERSION < 4)
 #define ttyslot() 1
 #endif /* apollo */
 
@@ -284,7 +279,7 @@
 #define pututline pututxline
 #else
 #include <utmp.h>
-#if defined(_CRAY) && OSMAJORVERSION < 8
+#if defined(_CRAY) && (OSMAJORVERSION < 8)
 extern struct utmp *getutid __((struct utmp *_Id));
 #endif
 #endif
@@ -292,7 +287,15 @@
 #ifdef LASTLOG
 #include <lastlog.h>
 #endif
+
+/* Xpoll.h and <sys/param.h> on glibc 2.1 systems have colliding NBBY's */
+#if defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
+#ifndef NOFILE
+#define NOFILE OPEN_MAX
+#endif
+#elif !defined(MINIX) && !defined(WIN32) && !defined(Lynx) && !defined(__GNU__)
 #include <sys/param.h>	/* for NOFILE */
+#endif
 
 #ifdef  PUCC_PTYD
 #include <local/openpty.h>
@@ -387,6 +390,9 @@
 
 int switchfb[] = {0, 2, 1, 3};
 
+#undef  CTRL
+#define        CTRL(c) ((c) & 0x1f)
+
 static SIGNAL_T reapchild (int n);
 
 static Bool added_utmp_entry = False;
@@ -398,12 +404,15 @@
 ** to eliminate any assumptions about the internal order of their
 ** contents.
 */
+#ifndef ICRNL
+#include <sys/termio.h>
+#endif
 static struct termio d_tio;
 #ifdef TIOCSLTC
 static struct ltchars d_ltc;
 #endif	/* TIOCSLTC */
 
-#ifdef sgi
+#if defined (__sgi) || (defined(__linux__) && defined(__sparc__))
 #undef TIOCLSET /* XXX why is this undef-ed again? */
 #endif
 
@@ -432,15 +441,17 @@
 #endif /* sony */
 #endif /* USE_SYSV_TERMIO */
 
+#define VAL_INITIAL_ERASE 127
+
 /* allow use of system default characters if defined and reasonable */
 #ifndef CEOF
-#define CEOF ('D'&037)
+#define CEOF CTRL('D')
 #endif
 #ifndef CSUSP
-#define CSUSP ('Z'&037)
+#define CSUSP CTRL('Z')
 #endif
 #ifndef CQUIT
-#define CQUIT ('\\'&037)
+#define CQUIT CTRL('\\')
 #endif
 #ifndef CEOL
 #define CEOL 0
@@ -449,22 +460,22 @@
 #define CSWTCH 0
 #endif
 #ifndef CLNEXT
-#define CLNEXT ('V'&037)
+#define CLNEXT CTRL('V')
 #endif
 #ifndef CWERASE
-#define CWERASE ('W'&037)
+#define CWERASE CTRL('W')
 #endif
 #ifndef CRPRNT
-#define CRPRNT ('R'&037)
+#define CRPRNT CTRL('R')
 #endif
 #ifndef CFLUSH
-#define CFLUSH ('O'&037)
+#define CFLUSH CTRL('O')
 #endif
 #ifndef CSTOP
-#define CSTOP ('S'&037)
+#define CSTOP CTRL('S')
 #endif
 #ifndef CSTART
-#define CSTART ('Q'&037)
+#define CSTART CTRL('Q')
 #endif
 
 struct _xttymodes {
@@ -517,7 +528,7 @@
 };
 
 #ifdef USE_SYSV_UTMP
-#if defined(X_NOT_STDC_ENV) || (defined(AIXV3) && OSMAJORVERSION < 4)
+#if defined(X_NOT_STDC_ENV) || (defined(AIXV3) && (OSMAJORVERSION < 4))
 extern struct utmp *getutent();
 extern struct utmp *getutid();
 extern struct utmp *getutline();
@@ -1082,9 +1093,9 @@
         d_tio.c_cflag &= ~(HUPCL|PARENB);
         d_tio.c_iflag |= BRKINT|ISTRIP|IGNPAR;
 #endif
-	d_tio.c_cc[VINTR] = 'C' & 0x3f;		/* '^C'	*/
+	d_tio.c_cc[VINTR] = CTRL('C');		/* '^C'	*/
 	d_tio.c_cc[VERASE] = 0x7f;		/* DEL	*/
-	d_tio.c_cc[VKILL] = 'U' & 0x3f;		/* '^U'	*/
+	d_tio.c_cc[VKILL] = CTRL('U');		/* '^U'	*/
 	d_tio.c_cc[VQUIT] = CQUIT;		/* '^\'	*/
     	d_tio.c_cc[VEOF] = CEOF;		/* '^D'	*/
 	d_tio.c_cc[VEOL] = CEOL;		/* '^@'	*/
@@ -1475,7 +1486,7 @@
 	screen->inhibit = inhibit;
 
 #ifdef AIXV3
-#if OSMAJORVERSION < 4
+#if (OSMAJORVERSION < 4)
 	/* In AIXV3, xterms started from /dev/console have CLOCAL set.
 	 * This means we need to clear CLOCAL so that SIGHUP gets sent
 	 * to the slave-pty process when xterm exits. 
@@ -1551,7 +1562,10 @@
 
 int get_pty (int *pty)
 {
-#if defined(SYSV) && defined(i386) && !defined(SVR4)
+#if defined(__osf__) || (defined(__GLIBC__) && !defined(USE_USG_PTYS))
+  int tty;
+  return (openpty(pty, &tty, ttydev, NULL, NULL));
+#elif defined(SYSV) && defined(i386) && !defined(SVR4)
         /*
 	  The order of this code is *important*.  On SYSV/386 we want to open
 	  a /dev/ttyp? first if at all possible.  If none are available, then
@@ -1577,27 +1591,33 @@
 	  */
         if (pty_search(pty) == 0)
 	    return 0;
-#endif /* SYSV && i386 && !SVR4 */
-#if (defined(ATT) || defined(__CYGWIN32__)) && !defined(sgi)
+#elif defined(USE_USG_PTYS)
+#ifdef __GLIBC__ /* if __GLIBC__ and USE_USG_PTYS, we know glibc >= 2.1 */
+	/* GNU libc 2 allows us to abstract away from having to know the
+	   master pty device name. */
+	if ((*pty = getpt()) < 0) {
+	  return 1;
+	}
+	strcpy(ttydev, ptsname(*pty));
+#else
 	if ((*pty = open ("/dev/ptmx", O_RDWR)) < 0) {
 	    return 1;
 	}
-#if defined(SVR4) || defined(__CYGWIN32__) || defined(i386)
+#endif
+#if defined(SVR4) || defined(SCO325) || (defined(i386) && defined(SYSV))
 	strcpy(ttydev, (char *)ptsname(*pty));
 #if defined (SYSV) && defined(i386) && !defined(SVR4)
 	IsPts = True;
 #endif
 #endif
 	return 0;
-#else /* ATT else */
-#ifdef AIXV3
+#elif defined(AIXV3)
 	if ((*pty = open ("/dev/ptc", O_RDWR)) < 0) {
 	    return 1;
 	}
 	strcpy(ttydev, ttyname(*pty));
 	return 0;
-#endif
-#if defined(sgi) && OSMAJORVERSION >= 4
+#elif defined(__sgi) && (OSMAJORVERSION >= 4)
 	{
 	    char    *tty_name;
 
@@ -1607,8 +1627,7 @@
 	    strcpy (ttydev, tty_name);
 	    return 0;
 	}
-#endif
-#ifdef __convex__
+#elif defined(__convex__)
         {
 	    char *pty_name, *getpty();
 
@@ -1622,11 +1641,9 @@
 	    }
 	    return 1;
 	}
-#endif /* __convex__ */
-#ifdef USE_GET_PSEUDOTTY
+#elif defined(USE_GET_PSEUDOTTY)
 	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
-#else
-#if (defined(sgi) && OSMAJORVERSION < 4) || (defined(umips) && defined (SYSTYPE_SYSV))
+#elif (defined(__sgi) && (OSMAJORVERSION < 4)) || (defined(umips) && defined (SYSTYPE_SYSV))
 	struct stat fstat_buf;
 
 	*pty = open ("/dev/ptc", O_RDWR);
@@ -1634,22 +1651,30 @@
 	  return(1);
 	}
 	sprintf (ttydev, "/dev/ttyq%d", minor(fstat_buf.st_rdev));
-#ifndef sgi
+#ifndef __sgi
 	sprintf (ptydev, "/dev/ptyq%d", minor(fstat_buf.st_rdev));
 	if ((*tty = open (ttydev, O_RDWR)) < 0) {
 	  close (*pty);
 	  return(1);
 	}
-#endif /* !sgi */
+#endif /* !__sgi */
 	/* got one! */
 	return(0);
-#else /* sgi or umips */
-#if !(defined(sgi) && OSMAJORVERSION >= 4)
+#else /* __sgi or umips */
+
+#ifdef __hpux
+	/*
+	 * Use the clone device if it works, otherwise use pty_search logic.
+	 */
+	if ((*pty = open("/dev/ptym/clone", O_RDWR)) >= 0) {
+	  strcpy(ttydev, ptsname(*pty));
+	  return(0);
+	}
+#endif
+
 	return pty_search(pty);
+
 #endif
-#endif /* sgi or umips else */
-#endif /* USE_GET_PSEUDOTTY else */
-#endif /* ATT else */
 }
 
 /*
@@ -1869,8 +1894,6 @@
 	int Xsocket = ConnectionNumber(screen->display);
 #ifdef USE_HANDSHAKE
 	handshake_t handshake;
-#else
-	int fds[2];
 #endif
 	int tty = -1;
 	int discipline;
@@ -1922,7 +1945,7 @@
 #endif	/* sun */
 	struct passwd *pw = NULL;
 #ifdef UTMP
-#ifdef SVR4
+#ifdef SVR4 || defined(SCO325)) && !defined(__CYGWIN32__)
 	struct utmpx utmp;
 #else
 	struct utmp utmp;
@@ -1935,10 +1958,8 @@
 	screen->uid = getuid();
 	screen->gid = getgid();
 
-#ifdef linux
-	bzero(termcap, sizeof termcap);
-	bzero(newtc, sizeof newtc);
-#endif
+    termcap[0] = '\0';
+    newtc[0] = '\0';
 
 #ifdef SIGTTOU
 	/* so that TIOCSWINSZ || TIOCSIZE doesn't block */
@@ -1947,11 +1968,12 @@
 
 	if (am_slave) {
 		screen->respond = am_slave;
+#ifndef __osf__
 		ptydev[strlen(ptydev) - 2] = ttydev[strlen(ttydev) - 2] =
 			passedPty[0];
 		ptydev[strlen(ptydev) - 1] = ttydev[strlen(ttydev) - 1] =
 			passedPty[1];
-
+#endif /* __osf__ */
 		setgid (screen->gid);
 		setuid (screen->uid);
 	} else {
@@ -1980,22 +2002,20 @@
 		 * no controlling terminal, but some systems (e.g. SunOS 4.0)
 		 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
 		 */
+		no_dev_tty = FALSE;
  		if (tty < 0) {
 			if (tty_got_hung || errno == ENXIO || errno == EIO ||
-			    errno == EINVAL || errno == ENOTTY) {
+			    errno == EINVAL || errno == ENOTTY || errno == EACCES) {
 				no_dev_tty = TRUE;
 #ifdef TIOCSLTC
 				ltc = d_ltc;
 #endif	/* TIOCSLTC */
-#if defined(sun) && defined(SVR4)
-#undef TIOCLSET
-#endif
 #ifdef TIOCLSET
 				lmode = d_lmode;
 #endif	/* TIOCLSET */
-#ifdef USE_SYSV_TERMIO
+#if defined(USE_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)
 				tio = d_tio;
-#else	/* not USE_SYSV_TERMIO */
+#else	/* not USE_SYSV_TERMIO and not USE_POSIX_TERMIOS */
 				sg = d_sg;
 				tc = d_tc;
 				discipline = d_disipline;
@@ -2003,7 +2023,7 @@
 				jmode = d_jmode;
 				jtc = d_jtc;
 #endif /* sony */
-#endif	/* USE_SYSV_TERMIO */
+#endif	/* USE_SYSV_TERMIO or USE_POSIX_TERMIOS */
 			} else {
 			    SysError(ERROR_OPDEVTTY);
 			}
@@ -2025,8 +2045,10 @@
 #ifdef USE_SYSV_TERMIO
 		        if(ioctl(tty, TCGETA, &tio) == -1)
 			        tio = d_tio;
-
-#else	/* not USE_SYSV_TERMIO */
+#elif defined(USE_POSIX_TERMIOS)
+				if (tcgetattr(tty, &tio) == -1)
+					tio = d_tio;
+#else	/* !USE_SYSV_TERMIO && !USE_POSIX_TERMIOS */
 			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
 			        sg = d_sg;
 			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
@@ -2048,19 +2070,16 @@
 #ifdef 	PUCC_PTYD
 		if(-1 == (screen->respond = openrpty(ttydev, ptydev,
 				(resource.utmpInhibit ?  OPTY_NOP : OPTY_LOGIN),
-				getuid(), XDisplayString(screen->display)))) {
+				getuid(), XDisplayString(screen->display))))
 #else /* not PUCC_PTYD */
-		if (get_pty (&screen->respond)) {
+		if (get_pty (&screen->respond)) 
 #endif /* PUCC_PTYD */
+		  {
 			/*  no ptys! */
 			(void) fprintf(stderr, "%s: no available ptys\n",
 				       xterm_name);
 			exit (ERROR_PTYS);
-#ifdef PUCC_PTYD
 		}
-#else
-		}			/* keep braces balanced for emacs */
-#endif
 #ifdef PUCC_PTYD
 		  else {
 			/*
@@ -2170,7 +2189,7 @@
 		 * now in child process
 		 */
 		extern char **environ;
-#if defined(_POSIX_SOURCE) || defined(SVR4) || defined(__CYGWIN32__) || defined(__convex__)
+#if defined(_POSIX_SOURCE) || defined(SVR4) || defined(__convex__) || defined(SCO325)
 		int pgrp = setsid();
 #else
 		int pgrp = getpid();
@@ -2182,8 +2201,8 @@
 		char *ptyname;
 #endif
 
-#if defined(USE_USG_PTYS) || defined(__CYGWIN32__)
-#if defined(SYSV) && defined(i386) && !defined(SVR4) && ! defined(__CYGWIN32__)
+#if defined(USE_USG_PTYS)
+#if defined(SYSV) && defined(i386) && !defined(SVR4)
                 if (IsPts) {	/* SYSV386 supports both, which did we open? */
 #endif /* SYSV && i386 && !SVR4 */
 		int ptyfd;
@@ -2194,23 +2213,19 @@
 		if ((ptyfd = open ((char *)ptsname(screen->respond), O_RDWR)) < 0) {
 		    SysError (1);
 		}
-#ifndef __CYGWIN32__
+#ifdef I_PUSH
 		if (ioctl (ptyfd, I_PUSH, "ptem") < 0) {
 		    SysError (2);
 		}
-#endif
-#if !defined(SVR4) && !(defined(SYSV) && defined(i386)) && ! defined(__CYGWIN32__)
+#if !defined(SVR4) && !(defined(SYSV) && defined(i386))
 		if (!getenv("CONSEM") && ioctl (ptyfd, I_PUSH, "consem") < 0) {
 		    SysError (3);
 		}
 #endif /* !SVR4 */
-#ifndef __CYGWIN32__
 		if (ioctl (ptyfd, I_PUSH, "ldterm") < 0) {
 		    SysError (4);
 		}
-#endif
 #ifdef SVR4		/* from Sony */
-# ifndef NO_TTCOMPAT		/* ! (sgi && IRIX 5.x) */
 		if (ioctl (ptyfd, I_PUSH, "ttcompat") < 0) {
 		    SysError (5);
 		}
@@ -2232,7 +2247,7 @@
                         ws.ws_ypixel = FullHeight(screen);
                 }
 #endif
-#if defined(SYSV) && defined(i386) && !defined(SVR4) && ! defined(__CYGWIN32__)
+#if defined(SYSV) && defined(i386) && !defined(SVR4)
                 } else {	/* else pty, not pts */
 #endif /* SYSV && i386 && !SVR4 */
 #endif /* USE_USG_PTYS */
@@ -2266,7 +2281,7 @@
 		/* Now is the time to set up our process group and
 		 * open up the pty slave.
 		 */
-#if defined(USE_SYSV_PGRP) && ! defined(__CYGWIN32__)
+#if defined(USE_SYSV_PGRP)
 #if defined(CRAY) && (OSMAJORVERSION > 5)
 		(void) setsid();
 #else
@@ -2274,18 +2289,18 @@
 #endif
 #endif /* USE_SYSV_PGRP */
 		while (1) {
-#ifdef TIOCNOTTY
+#if defined(TIOCNOTTY) && !((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
 			if (!no_dev_tty && (tty = open ("/dev/tty", O_RDWR)) >= 0) {
 				ioctl (tty, TIOCNOTTY, (char *) NULL);
 				close (tty);
 			}
-#endif /* TIOCNOTTY */
+#endif /* TIOCNOTTY && !glibc >= 2.1 */
 			if ((tty = open(ttydev, O_RDWR, 0)) >= 0) {
 #if defined(CRAY) && defined(TCSETCTTY)
 			    /* make /dev/tty work */
 			    ioctl(tty, TCSETCTTY, 0);
 #endif
-#if defined(USE_SYSV_PGRP) && ! defined(__CYGWIN32__)
+#if defined(USE_SYSV_PGRP)
 				/* We need to make sure that we are acutally
 				 * the process group leader for the pty.  If
 				 * we are, then we should now be able to open
@@ -2341,7 +2356,7 @@
 			ttydev = (char *)realloc (ttydev, (unsigned) (strlen(ptr) + 1));
 			(void) strcpy(ttydev, ptr);
 		}
-#if defined(SYSV) && defined(i386) && !defined(SVR4) && ! defined(__CYGWIN32__)
+#if defined(SYSV) && defined(i386) && !defined(SVR4)
                 } /* end of IsPts else clause */
 #endif /* SYSV && i386 && !SVR4 */
 
@@ -2771,7 +2786,7 @@
 			       sizeof(utmp.ut_name));
 
 		utmp.ut_pid = getpid();
-#ifdef SVR4
+#if defined(SVR4) || defined(SCO325) || (defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0)))
 		utmp.ut_session = getsid(0);
 		utmp.ut_xtime = time ((Time_t *) 0);
 		utmp.ut_tv.tv_usec = 0;
@@ -2783,9 +2798,12 @@
 		if (!resource.utmpInhibit)
 		    (void) pututline(&utmp);
 #ifdef WTMP
-#ifdef SVR4
+#if defined(SVR4) || defined(SCO325)
 		if (term->misc.login_shell)
 		    updwtmpx(WTMPX_FILE, &utmp);
+#elif defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0))
+		  if (term->misc.login_shell)
+                    updwtmp(etc_wtmp, &utmp);
 #else
 		if (term->misc.login_shell &&
 		     (i = open(etc_wtmp, O_WRONLY|O_APPEND)) >= 0) {
@@ -3169,7 +3187,7 @@
 	struct utmp *utptr;
 #endif
 	char *ptyname;
-#if defined(WTMP) && !defined(SVR4)
+#if defined(WTMP) && !defined(SVR4) && !(defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0)))
 	int fd;			/* for /etc/wtmp */
 	int i;
 #endif
@@ -3193,7 +3211,7 @@
 	    /* write it out only if it exists, and the pid's match */
 	    if (utptr && (utptr->ut_pid == screen->pid)) {
 		    utptr->ut_type = DEAD_PROCESS;
-#ifdef SVR4
+#if defined(SVR4) || defined(SCO325) || (defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0)))
 		    utmp.ut_session = getsid(0);
 		    utmp.ut_xtime = time ((Time_t *) 0);
 		    utmp.ut_tv.tv_usec = 0;
@@ -3202,8 +3220,13 @@
 #endif
 		    (void) pututline(utptr);
 #ifdef WTMP
-#ifdef SVR4
+#if defined(SVR4) || defined(SCO325)
+                    if (term->misc.login_shell)
 		    updwtmpx(WTMPX_FILE, &utmp);
+#elif defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0))
+		      strncpy (utmp.ut_line, utptr->ut_line, sizeof (utmp.ut_line));
+		      if (term->misc.login_shell)
+                        updwtmp(etc_wtmp, utptr);
 #else
 		    /* set wtmp entry if wtmp file exists */
 		    if ((fd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
@@ -3434,7 +3457,7 @@
 
 	if (*s == '^') {
 	    s++;
-	    c = ((*s == '?') ? 0177 : *s & 31);	 /* keep control bits */
+	    c = ((*s == '?') ? 0177 : CTRL(*s));	 /* keep control bits */
 	} else {
 	    c = *s;
 	}
Index: cxterm/ptyx.h
===================================================================
RCS file: /cvsroot/cxterm/cxterm/cxterm/ptyx.h,v
retrieving revision 1.4
retrieving revision 1.4.2.2
diff -u -b -B -r1.4 -r1.4.2.2
--- cxterm/ptyx.h	6 May 2003 07:40:19 -0000	1.4
+++ cxterm/ptyx.h	3 Aug 2004 17:33:31 -0000	1.4.2.2
@@ -1,4 +1,4 @@
-/* $Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $ */
+/* $Id: README.unix98,v 1.1.2.1 2004/08/04 20:17:49 htl10 Exp $ */
 /***********************************************************************
 * Copyright 1994 by Yongguang Zhang.
 * Copyright 1990, 1991 by Yongguang Zhang and Pong Man-Chi.
@@ -77,6 +77,16 @@
 ** System V definitions
 */
 
+#ifdef att
+#define ATT
+#endif
+
+#ifdef SVR4
+#undef  SYSV                   /* predefined on Solaris 2.4 */
+#define SYSV                   /* SVR4 is (approx) superset of SVR3 */
+#define ATT
+#endif
+
 #ifdef SYSV
 #ifdef X_NOT_POSIX
 #ifndef CRAY
@@ -87,24 +97,69 @@
 #endif /* SYSV */
 
 /*
+** Definitions to simplify ifdef's for pty's.
+*/
+#define USE_PTY_DEVICE 1
+#define USE_PTY_SEARCH 1
+
+#if defined(__osf__) || (defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && (__GLIBC_MINOR__ >= 1))
+#undef USE_PTY_DEVICE
+#undef USE_PTY_SEARCH
+#define USE_PTS_DEVICE 1
+#elif defined(VMS)
+#undef USE_PTY_DEVICE
+#undef USE_PTY_SEARCH
+#elif defined(PUCC_PTYD)
+#undef USE_PTY_SEARCH
+#endif
+
+#if defined(SYSV) && defined(i386) && !defined(SVR4)
+#define ATT
+#define USE_HANDSHAKE
+#define USE_ISPTS_FLAG 1
+#endif
+
+#if (defined(ATT) && !defined(__sgi)) || defined(__MVS__) || (defined(SYSV) && defined(i386)) || (defined (__GLIBC__) && ((__GLIBC__ > 2) || (__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
+#define USE_USG_PTYS
+#else
+#define USE_HANDSHAKE
+#endif
+
+/*
 ** allow for mobility of the pty master/slave directories
 */
 #ifndef PTYDEV
 #ifdef hpux
 #define	PTYDEV		"/dev/ptym/ptyxx"
-#else	/* !hpux */
+#elif defined(__MVS__)
+#define        PTYDEV          "/dev/ptypxxxx"
+#else
 #define	PTYDEV		"/dev/ptyxx"
-#endif	/* !hpux */
+#endif
 #endif	/* !PTYDEV */
 
 #ifndef TTYDEV
-#ifdef hpux
+#ifdef __hpux
 #define TTYDEV		"/dev/pty/ttyxx"
-#else	/* !hpux */
+#elif defined(__MVS__)
+#define TTYDEV         "/dev/ptypxxxx"
+#elif defined(USE_PTS_DEVICE)
+#define TTYDEV         "/dev/pts/0"
+#else
 #define	TTYDEV		"/dev/ttyxx"
-#endif	/* !hpux */
+#endif
 #endif	/* !TTYDEV */
 
+#ifndef PTYCHARLEN
+#ifdef CRAY
+#define PTYCHARLEN 3
+#elif defined(__MVS__)
+#define PTYCHARLEN 4
+#else
+#define PTYCHARLEN 2
+#endif
+#endif
+
 #ifndef PTYCHAR1
 #ifdef hpux
 #define PTYCHAR1	"zyxwvutsrqp"
@@ -163,8 +218,6 @@
 #define	NBOX	5			/* Number of Points in box	*/
 #define	NPARAM	10			/* Max. parameters		*/
 
-#define	MINHILITE	32
-
 typedef struct {
 	unsigned char	a_type;
 	unsigned char	a_pintro;
